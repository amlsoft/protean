(refer 'protean.core.transformation.sim)

(defn spel-print [list] (map (fn [x] (symbol (name x))) list))

(def world (atom
{
  'office-cubicle '((you are in your office cubicle)
    (west exit walkway))
  'walkway '((you are in the walkway at the side of the office -
    there is a photocopier in front of you -)
    (east exit office-cubicle)
    (north exit reception)
    (south exit bobs-office))
  'reception '((you are in reception -
    there is a receptionist droning on repetitively -)
    (south exit walkway))
  'bobs-office '((you in the Bobs office -
    there are two bobs expenctantly waiting to talk to you -)
    (north exit walkway))
}))

(def location (atom 'office-cubicle))

(defn describe-location [location world] (first (location world)))

(defn describe-path [path]
  `(there is an ~(second path) going ~(first path) from here -))

(defn describe-paths [location world]
  (apply concat (map describe-path (rest (get world location)))))

(defn look []
  (spel-print (concat (describe-location @location @world)
                      (describe-paths @location @world))))

(defn go-direction [direction]
  (let [next (first (filter (fn [x] (= direction (first x))) (rest (@location @world))))]
    (cond next (do (def location (atom (nth next 2))) (look))
          :else '(you cannot go that way -))))

(defmacro defspel [& rest] `(defmacro ~@rest))

(defspel go [direction] `(go-direction '~direction))


(defn get []
  (println "looking : " (look))
  (println "go : " (go west))
  (println "go : " (go north))
  {:status 200})

{
  "tutorial-7" {
    "play/${stateId}" {
      :get [#(get)]
    }
  }
}
