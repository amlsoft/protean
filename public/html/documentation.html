<!DOCTYPE html>
<html>
  <head>
    <title>Protean</title>
    <link rel="stylesheet" href="/resource/css/bootstrap.min.css">
    <link rel="stylesheet" href="/resource/css/bootstrap-theme.min.css">
    <link rel="stylesheet" media="screen" href="/resource/css/main.css">
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="/">Protean</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="/">Home</a></li>
            <li><a href="/documentation/api">API</a></li>
            <li class="active"><a href="/documentation">Documentation</a></li>
            <li><a href="/roadmap">Roadmap</a></li>
            <li><a href="/documentation/projects">Projects</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="#">v<span id="project-version">0.5.0</span></a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div id="documentation" class="container">
      <div class="page-header">
        <h1>Documentation</h1>
      </div>

      <section id="getting-started">
        <div class="page-header">
          <h2>Getting Started</h2>
        </div>

        <h3>Configuring the Protean port</h3>

        <p>
          Protean uses two ports - an <strong>admin</strong> port and an <strong>API</strong> port. The API port is used for simulating your RESTful services.  The admin port is used to manage your service definitions.  You can override the default API and admin ports with <code><kbd>java -jar protean.jar 4000 4001</kbd></code>.  This will launch the app with the admin port set to 4001 and the main projects API port set to 4000.
        </p>

        <h3>Setting up your services/projects</h3>

        <p>
          Protean works with the concepts of <strong>services</strong> and <strong>resources</strong>.  Services are your RESTful projects, comprised of one or more RESTful resources.  We configure one or more services in a Protean <strong>codex</strong>.  A codex is written in a JSON like format called <strong>EDN</strong> (Extensible Data Notation) which uses a <strong>.edn</strong> extension.
        </p>

        <p>
          Protean has a defaut <strong>sample</strong> service codex out of the box.  Any codices in the same directory as the runnable jar will be loaded on app startup.  Alternatively you can add new services to Protean with
        </p>

        <pre>
          <kbd>curl -v -X PUT http://locahost:3001/projects --data-binary "@/path/to/project.edn"</kbd>
          or
          <kbd>protean-cli add-projects -f /path/to/project.edn</kbd>
        </pre>

        <h3>Querying your services/projects</h3>

        <p>List all services:</p>
        <pre>
          <kbd>curl -v http://localhost:3001/projects</kbd>
          or
          <kbd>protean-cli projects</kbd>
        </pre>
        <br /><br />

        <p>Show a service configuration:</p>
        <pre>
          <kbd>curl -v http://localhost:3001/projects/sample</kbd>
          or
          <kbd>protean-cli project -n sample</kbd>
        </pre>
        <br /><br />

        <p>List curl commands for service resrouces:</p>
        <pre>
          <kbd>curl -v http://localhost:3001/projects/sample/usage</kbd>
          or
          <kbd>protean-cli project-usage</kbd>
        </pre>


        <h3>Testing your services/projects</h3>

        <p>
          Protean can automatically generate integration tests for simulations or real API's.  It can test across every service defined within the system or a specified range.  When testing real API's it is possible to pass in seed data for auth tokens and other pieces of information needed to represent the initial state of the system.  Protean will figure out the order to incrementally test endpoints, just supply a sequence of services or service/resource combinations.
        </p>

        <p>Integration testing the sample <strong>simulation</strong>:</p>
        <code><kbd>curl -v -X POST -H "Content-Type: application/json" --data '{"locs":["sample"]}}' 'http://localhost:3001/test'</kbd></code>
        <br /><br />

        <p>Integration testing a <strong>real</strong> API:</p>
        <code><kbd>curl -v -X POST -H "Content-Type: application/json" --data '{"host":"myhost","port":8000,locs":["myservice"]}}' 'http://localhost:3001/test'</kbd></code>
        <br /><br />
      </section>

      <section id="codices">
        <div class="page-header">
          <h2>Sample codices (project configurations)</h2>
        </div>

        <p>
          The simplest possible example of a codex is listed below:
        </p>

        <pre>
{:simple {:paths {"path/data" {}}}}
        </pre>

        <p>
          This creates a single resource which can be accessed with <code><kbd>curl -v http://localhost:3000/simple/path/data</kbd></code>.  This will return a 200 response with no body.
        </p>

        <p>
        It is possible to define more complex simulated project API's.  Below is the out of the box <a href="/#sample=project-api" target="_blank">sample</a> project API.
        </p>

        <pre>
{
  :sample {
    :paths {
      "get/simple" {:doc "Simplest example of a resource - doc is optional"}
      "get/test/*" {
        :doc "Get with path parameter wildcard and configurable
              error and probability"
        :rsp {
          :body {"t1key" "t1val"}
          :errors {:status [504] :probability 50}
        }
      }
      "random/test2" {
        :doc "Get with mandatory request headers/query str params"
        :req {
          :headers {"X-Auth" "XYZ"}
          :req-params {"blurb" "flibble"}
        }
        :rsp {:body {"t2key" "t2val"}}
      }
      "get/xml" {
        :doc "Get with XML content type/response"
        :rsp {
          :content-type "text/xml"
          :body [:parent [:child {:type "xml"}]]
        }
      }
      "post/test" {
        :doc "Post with mandatory request url encoded form"
        :req {
          :method :post
          :form {"k1" "v1"}
        }
        :rsp {:headers {"Location" "7"}}
      }
      "put/test1" {
        :doc "Put with mandatory body payload - defaults to JSON,
              demonstrates overriding response status code"
        :req {
          :method :put
          :body {"k1" "v1" "k2" "v2"}
        }
        :rsp {:status 200}
      }
      "delete/test" {
        :doc "Delete sample"
        :req {:method :delete}
      }
      "get/slow" {
        :doc "Get with slow response (secs) - useful for testing timeouts"
        :rsp {:time 2}
      }
    }
    :errors {:status [500 503] :probability 25}
  }
}
        </pre>

      </section>

    </div>
  </body>
</html>
